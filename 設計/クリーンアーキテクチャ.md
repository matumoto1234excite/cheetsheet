# クリーンアーキテクチャ

※2022/04/26に書いていて、まだまだ理解できてないので鵜吞みにしないこと
**追記**：2022/10/06エキサイトインターン終わりに追記した

## 一言でいうと？

参照（依存）関係がDAG

(Directed Acyclic Graph)

## レイヤーのみなさん

いつもの

![img](https://storage.googleapis.com/zenn-user-upload/5350c0c964c54234e298d593.jpg)



- model
- repository
- service
- usecase
- controller



みたいな感じのレイヤーがある（上記のレイヤーの参照関係は下から上）

### レイヤーの役割

基本的にAPIサーバーを例にしたときの役割を話していく

#### Controller

基本的に変換を行う層

- 外部からの入力を内部向けに変換する
- 内部からの入力を外部向けに変換する

例. 外部からの入力であるHTTPリクエストボディを取り出して、バリデーションなどをし、`Long`や`String` の値として内部(Usecase)に渡す

例2. 内部からの返り値をHTTPレスポンスボディやステータスコードとしてクライアントに返す

#### Usecase

複数のServiceを束ねる層
ビジネスロジックなどがここに当てはまる

ビジネスロジックがどういうものかというと、「日本語をそのままプログラミング言語に変換したような処理」、もしくは「プログラマー以外でも理解可能な処理」

for文もなるべく使いたくないレベルでありたい

例. getUserID()といったService層にある関数を使ったとして、返り値がnullであることを利用してユーザーの存在判定を行うより、userExists() といった関数をService層に生やして存在判定を行ったほうが良い

- よく、1Usecase1エンドポイントの形式が使われる
- また、1Usecaseでトランザクションを決めてしまうこともある
	- トランザクションをUsecase単位で決めるのは、トランザクションをビジネスロジックに寄せたいから ([参考](http://www.tricrow.com/blog/post/transaction/))

#### Service

これ以上分割できないドメイン単位の操作を行う層

ドメイン単位というのは、仕様上必要となる単位のこと
例. あるWebページの仕様としてユーザ情報が必要ならユーザ情報がドメイン単位

Service層にはパーツを書いていって、それをUsecase層で組み合わせる感じ
getUserByServiceId()であったり、userExists() であったり

#### Repository

外部との接続を行う層

DBとの接続だったり、他のAPIを叩いたりなど
